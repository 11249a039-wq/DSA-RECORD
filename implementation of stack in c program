#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt; 
#include &lt;string.h&gt;
#define MAX 100
typedef struct {
char arr[MAX];
int top;
} Stack;
void init(Stack *s) {
s-&gt;top = -1;
}
int isEmpty(Stack *s) {
return s-&gt;top == -1;
}
int isFull(Stack *s) {
return s-&gt;top == MAX - 1;
}
void push(Stack *s, char c) {
if (!isFull(s)) {
s-&gt;arr[++(s-&gt;top)] = c;
}
}
char pop(Stack *s) {
if (!isEmpty(s)) {
return s-&gt;arr[(s-&gt;top)--];
}
return &#39;\0&#39;;
}
char peek(Stack *s) {

if (!isEmpty(s)) {
return s-&gt;arr[s-&gt;top];
}
return &#39;\0&#39;;
}
int precedence(char op) {
switch (op) {
case &#39;+&#39;:
case &#39;-&#39;: return 1;
case &#39;*&#39;:
case &#39;/&#39;: return 2;
case &#39;^&#39;: return 3;
}
return 0;
}
int isOperator(char c) {
return c == &#39;+&#39; || c == &#39;-&#39; || c == &#39;*&#39; || c == &#39;/&#39; || c == &#39;^&#39;;
}
void infixToPostfix(char* infix, char* postfix) {
Stack s;
init(&amp;s);
int k = 0; // Index for postfix
for (int i = 0; infix[i] != &#39;\0&#39;; i++) {
char c = infix[i];
if (isalnum(c)) {
postfix[k++] = c;
}
else if (c == &#39;(&#39;) {
push(&amp;s, c);
}
else if (c == &#39;)&#39;) {
while (!isEmpty(&amp;s) &amp;&amp; peek(&amp;s) != &#39;(&#39;) {
postfix[k++] = pop(&amp;s);
}
pop(&amp;s); 
}
else if (isOperator(c)) {
while (!isEmpty(&amp;s) &amp;&amp; precedence(peek(&amp;s)) &gt;= precedence(c)) {
if (c == &#39;^&#39; &amp;&amp; peek(&amp;s) == &#39;^&#39;) {
operator
break;
} else {
postfix[k++] = pop(&amp;s);
}
}
push(&amp;s, c);
}
}
while (!isEmpty(&amp;s)) {
postfix[k++] = pop(&amp;s);
}
postfix[k] = &#39;\0&#39;; 
}

int main() {
char infix[MAX];
char postfix[MAX];
printf(&quot;Enter infix expression: &quot;);
fgets(infix, MAX, stdin);
infix[strcspn(infix, &quot;\n&quot;)] = &#39;\0&#39;;
infixToPostfix(infix, postfix);
printf(&quot;Postfix expression: %s\n&quot;, postfix);
return 0;
}
